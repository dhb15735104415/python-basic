'''
    记录包和模块导入时的相对导入和绝对导入和python可执行文件的特点
    背景:一开始mian.py在'day12_相对导入和绝对导入'这个包下,和package1包是平级的
'''
#一、经典误区：m1程序的顶级包是codes吗？
#在main.py中导入m1模块
print("m1的__package__值:",__package__)   #m1的__package__值: package1
'''
执行
从输出结果来看，codes并不是m1程序的顶级包，而是package1
m1程序的顶级包是由导入m1程序的模块来决定的，在本项目中是入口文件main.py，为什么是由入口文件来决定？
    因为对于入口文件来讲，它自己本身没有包这个概念的，本质是用python命令来执行的，而在该项目中main.py导入了package1.m1模块
所以在执行main.py入口文件时先去导入m1模块，即执行m1模块的代码。main.py文件和package1是平级的，只能检索到与入口文件同级的包，
所以就输出了结果：m1的__package__值: package1 ，而不是'day12_相对导入和绝对导入'，更不是codes
一句话总结：与入口文件同级的包才是m1模块的顶级包

测试：将main.py移动到pyhton-basic目录下，那么会发生什么结果呢？
执行命令:python main.py  会报错，详见：pictures/入口文件决定了导入模块的顶级包.png
但是，但是，但是，我发现在直接在IDEA运行codes目录下的main.py时，并不会报错，而是成功运行，并且输出的结果和之前的一样
这是因为IDEA自动去找要导入模块的路径，找到则会成功输出结果。而使用python命令去执行时，是在某路径下(固定的)来执行命令，所以会报错
'''
#二、绝对导入
'''
import  package1.m1  这段代码是通过 顶级包.模块名 来导入相应的模块，这种导入称为绝对导入
'''