'''
    记录包和模块导入时的相对导入和绝对导入和python可执行文件的特点
    背景:一开始mian.py在'day12_相对导入和绝对导入'这个包下,和package1包是平级的
'''
temp1 = 1
#一、经典误区：m1程序的顶级包是codes吗？
#在main.py中导入m1模块
print("m1模块的__package__值:",__package__)   #m1的__package__值: package1
'''
执行
从输出结果来看，codes并不是m1程序的顶级包，而是package1
m1程序的顶级包是由导入m1程序的模块来决定的，在本项目中是入口文件main.py，为什么是由入口文件来决定？
    因为对于入口文件来讲，它自己本身没有包这个概念的，本质是用python命令来执行的，而在该项目中main.py导入了package1.m1模块
所以在执行main.py入口文件时先去导入m1模块，即执行m1模块的代码。main.py文件和package1是平级的，只能检索到与入口文件同级的包，
所以就输出了结果：m1的__package__值: package1 ，而不是'day12_相对导入和绝对导入'，更不是codes
一句话总结：与入口文件同级的包才是m1模块的顶级包

测试：将main.py移动到pyhton-basic目录下，那么会发生什么结果呢？
执行命令:python main.py  会报错，详见：pictures/入口文件决定了导入模块的顶级包.png
但是，但是，但是，我发现在直接在IDEA运行codes目录下的main.py时，并不会报错，而是成功运行，并且输出的结果和之前的一样
这是因为IDEA自动去找要导入模块的路径，找到则会成功输出结果。而使用python命令去执行时，是在某路径下(固定的)来执行命令，所以会报错
'''
#二、绝对导入   是基于绝对路径而言的
'''
main.py中import  package1.package4.m4  这段代码是通过 顶级包.子包.模块名 来导入相应的模块，这种导入称为绝对导入
如果想要使用绝对导入的方式来导入模块，就必须明白哪个才是顶级包，这也是花费大篇幅来先介绍顶级包的目的。
'''

#三、相对导入   是基于相对路径而言的，在python中 '.'表示当前路径，'..'表示上一级路径，'...'表示上上一级路径，以此类推
'''
在入口文件是无法使用相对导入来导入模块的，为什么呢？
因为相对导入，'.'是来获取__name__的值，而入口文件的__name__的值是'__main__'
因此：from .package1.package4.m4 temp4  等价于  __main__.package1.package4.m4.m4   ,__main__下当然没有package4.m4了，所以不能在入口文件
使用相对导入的方式来导入包或模块
在/package1/package4/m4.py 来验证相对导入

思考：难道python的入口文件就支持绝对导入吗？答案是否定的，如果想要在入口文件使用相对导入，那么只需要是'__name__'的
值不是'__main__'就可以了。。所以使用python -m 命令，将入口文件当作是模块来执行就OK了
实践:
第一步：cd 到codes目录
第二步：注释掉其他导入的代码，只留from .package1.package4.m4 temp4 
第三步：执行命令：python -m day12_相对导入和绝对导入.main
可以发现结果是正确的，详见：pictures/入口文件使用相对导入且成功运行.png
'''